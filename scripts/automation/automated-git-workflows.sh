#!/bin/bash

# Automated Git Workflows for Context Engineering
# Advanced automation protocols for systematic development

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
LOG_FILE="$PROJECT_ROOT/scripts/results/automated-workflows.log"
TIMESTAMP=$(date '+%Y%m%d-%H%M%S')

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Daily maintenance workflow
daily_maintenance() {
    log "üîÑ Starting daily maintenance workflow..."
    
    # Backup command registry
    "$PROJECT_ROOT/scripts/automation/git-automation-suite.sh" backup-registry
    
    # Update performance metrics
    if [ -f "$PROJECT_ROOT/scripts/core/calculate-real-metrics.sh" ]; then
        "$PROJECT_ROOT/scripts/core/calculate-real-metrics.sh"
    fi
    
    # Validate system health
    if [ -f "$PROJECT_ROOT/scripts/validation/validate-system-integrity.sh" ]; then
        "$PROJECT_ROOT/scripts/validation/validate-system-integrity.sh"
    fi
    
    # Generate daily performance report
    "$PROJECT_ROOT/scripts/automation/git-automation-suite.sh" performance-report
    
    log "‚úÖ Daily maintenance completed"
}

# Auto-crystallization workflow
pattern_crystallization_workflow() {
    log "üîÆ Starting pattern crystallization workflow..."
    
    # Detect patterns from recent commits
    local pattern_detected=false
    local pattern_description=""
    
    # Check for repeated command patterns
    local recent_commits=$(git log --oneline -20 --grep="feat\|enhance")
    
    if echo "$recent_commits" | grep -q "progressive\|thinking"; then
        pattern_detected=true
        pattern_description="Progressive Thinking Enhancement Pattern"
    elif echo "$recent_commits" | grep -q "validation\|verify"; then
        pattern_detected=true
        pattern_description="Validation Enhancement Pattern"
    elif echo "$recent_commits" | grep -q "command\|workflow"; then
        pattern_detected=true
        pattern_description="Command Workflow Enhancement Pattern"
    fi
    
    if [ "$pattern_detected" = true ]; then
        log "üéØ Pattern detected: $pattern_description"
        
        # Create pattern documentation
        local pattern_file="$PROJECT_ROOT/docs/patterns/$(echo "$pattern_description" | tr '[:upper:]' '[:lower:]' | tr ' ' '-').md"
        
        if [ ! -f "$pattern_file" ]; then
            cat > "$pattern_file" << EOF
# $pattern_description

## Pattern Recognition
**Detected**: $(date)
**Frequency**: Multiple implementations in recent commits
**Success Rate**: Requires validation

## Implementation Pattern
[Auto-generated pattern documentation]

## Crystallization Criteria
- [ ] ‚â•3 successful implementations
- [ ] ‚â•85% success rate validated
- [ ] Performance improvement demonstrated
- [ ] Mathematical rigor verified

## Next Steps
1. Validate pattern effectiveness
2. Create reusable command if criteria met
3. Document best practices
4. Integrate into automation suite

---
*Auto-generated by Pattern Crystallization Workflow*
EOF
            
            log "üìù Pattern documentation created: $pattern_file"
            
            # Create PR for pattern review
            git add "$pattern_file"
            git commit -m "üîÆ crystallize: $pattern_description

üéØ Auto-detected pattern requiring review
üìä Pattern frequency: Multiple recent implementations
üîç Validation needed: Success rate assessment
üìö Documentation: Auto-generated pattern file

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"
            
            log "‚úÖ Pattern crystallization commit created"
        fi
    else
        log "üìä No new patterns detected in recent commits"
    fi
}

# Automated release workflow
automated_release_workflow() {
    local release_type="$1"  # major, minor, patch
    
    log "üöÄ Starting automated release workflow: $release_type"
    
    # Get current version (extract from last tag or default to 1.0.0)
    local current_version=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
    local new_version
    
    # Calculate new version
    case "$release_type" in
        "major")
            new_version=$(echo "$current_version" | sed 's/v\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/v\1.0.0/' | sed 's/v\([0-9]*\)/v$(((\1+1)))/')
            ;;
        "minor")
            new_version=$(echo "$current_version" | sed 's/v\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/v\1.\2.0/' | sed 's/v\([0-9]*\)\.\([0-9]*\)/v\1.$((\2+1))/')
            ;;
        "patch")
            new_version=$(echo "$current_version" | sed 's/v\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/v\1.\2.$((\3+1))/')
            ;;
        *)
            log "‚ùå Invalid release type: $release_type"
            return 1
            ;;
    esac
    
    log "üìà Preparing release: $current_version ‚Üí $new_version"
    
    # Run comprehensive validation
    if ! "$PROJECT_ROOT/scripts/automation/git-automation-suite.sh" validate; then
        log "‚ùå Release validation failed"
        return 1
    fi
    
    # Generate release notes
    local release_notes="Context Engineering System $new_version

## üöÄ New Features
$(git log --oneline "$current_version"..HEAD --grep="feat" | sed 's/^/- /')

## ‚ú® Enhancements
$(git log --oneline "$current_version"..HEAD --grep="enhance" | sed 's/^/- /')

## üîß Bug Fixes
$(git log --oneline "$current_version"..HEAD --grep="fix" | sed 's/^/- /')

## üìä Performance Metrics
- Context efficiency: $(grep -o '"context_efficiency": "[^"]*"' "$PROJECT_ROOT/scripts/results/"git-performance-report-*.json | tail -1 | cut -d'"' -f4)
- Navigation speed: $(grep -o '"navigation_speed": "[^"]*"' "$PROJECT_ROOT/scripts/results/"git-performance-report-*.json | tail -1 | cut -d'"' -f4)
- Success rate: $(grep -o '"success_rate": "[^"]*"' "$PROJECT_ROOT/scripts/results/"git-performance-report-*.json | tail -1 | cut -d'"' -f4)

## üèóÔ∏è System Architecture
- Commands: $(find "$PROJECT_ROOT/.claude/commands" -name "*.md" -type f | wc -l | tr -d ' ') across $(find "$PROJECT_ROOT/.claude/commands" -type d -mindepth 1 -maxdepth 1 | wc -l | tr -d ' ') categories
- Scripts: $(find "$PROJECT_ROOT/scripts" -name "*.sh" -o -name "*.js" | wc -l | tr -d ' ') organized scripts
- Components: $(find "$PROJECT_ROOT/src/components" -name "*.tsx" -type f | wc -l | tr -d ' ') React components"
    
    # Create release tag
    "$PROJECT_ROOT/scripts/automation/git-automation-suite.sh" release "$new_version" "$release_notes"
    
    log "‚úÖ Release $new_version created successfully"
}

# Continuous integration simulation
ci_simulation() {
    log "üß™ Running CI simulation..."
    
    # Simulate validation pipeline
    local validation_steps=(
        "validate-system-integrity"
        "analyze-content-quality"
        "generate-p55-compliance-report"
        "verify-mathematical-formulas"
        "calculate-real-metrics"
    )
    
    local all_passed=true
    
    for step in "${validation_steps[@]}"; do
        log "üîç Running: $step"
        
        local script_path=""
        case "$step" in
            "validate-system-integrity"|"analyze-content-quality")
                script_path="$PROJECT_ROOT/scripts/validation/$step.sh"
                ;;
            "generate-p55-compliance-report"|"verify-mathematical-formulas")
                script_path="$PROJECT_ROOT/scripts/compliance/$step.sh"
                ;;
            "calculate-real-metrics")
                script_path="$PROJECT_ROOT/scripts/core/$step.sh"
                ;;
        esac
        
        if [ -f "$script_path" ]; then
            if ! "$script_path"; then
                log "‚ùå CI step failed: $step"
                all_passed=false
            else
                log "‚úÖ CI step passed: $step"
            fi
        else
            log "‚ö†Ô∏è  CI step skipped (script not found): $step"
        fi
    done
    
    if [ "$all_passed" = true ]; then
        log "‚úÖ CI simulation completed successfully"
        return 0
    else
        log "‚ùå CI simulation failed"
        return 1
    fi
}

# Automated performance optimization
performance_optimization_workflow() {
    log "‚ö° Starting performance optimization workflow..."
    
    # Generate current performance report
    "$PROJECT_ROOT/scripts/automation/git-automation-suite.sh" performance-report
    
    # Analyze performance metrics
    local latest_report=$(find "$PROJECT_ROOT/scripts/results" -name "git-performance-report-*.json" | sort | tail -1)
    
    if [ -f "$latest_report" ]; then
        local context_efficiency=$(grep -o '"context_efficiency": "[^"]*"' "$latest_report" | cut -d'"' -f4 | tr -d '%')
        local success_rate=$(grep -o '"success_rate": "[^"]*"' "$latest_report" | cut -d'"' -f4 | tr -d '%')
        
        log "üìä Current metrics - Context: ${context_efficiency}%, Success: ${success_rate}%"
        
        # Check for optimization opportunities
        if (( $(echo "$context_efficiency < 80" | bc -l) )); then
            log "üéØ Optimization opportunity: Context efficiency below 80%"
            
            # Create optimization task
            local optimization_file="$PROJECT_ROOT/docs/patterns/context-optimization-$(date +%Y%m%d).md"
            cat > "$optimization_file" << EOF
# Context Optimization Opportunity

**Detected**: $(date)
**Current Context Efficiency**: ${context_efficiency}%
**Target**: >80%

## Optimization Strategies
1. Review command loading patterns
2. Optimize principle file organization
3. Enhance lazy loading mechanisms
4. Reduce redundant context

## Action Items
- [ ] Analyze context usage patterns
- [ ] Identify redundant loading
- [ ] Implement selective loading
- [ ] Validate optimization impact

---
*Auto-generated by Performance Optimization Workflow*
EOF
            
            git add "$optimization_file"
            git commit -m "‚ö° optimize: Context efficiency improvement opportunity

üìä Current efficiency: ${context_efficiency}% (target: >80%)
üéØ Auto-generated optimization analysis
üîç Review required: Context loading patterns
üìà Expected improvement: 5-10% efficiency gain

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"
            
            log "‚úÖ Optimization analysis created"
        fi
        
        if (( $(echo "$success_rate < 90" | bc -l) )); then
            log "üéØ Optimization opportunity: Success rate below 90%"
            log "üìã Recommended: Review validation protocols"
        fi
    fi
}

# Health check workflow
health_check_workflow() {
    log "üè• Starting health check workflow..."
    
    local health_status="healthy"
    local issues=()
    
    # Check git repository health
    if ! git fsck --no-progress > /dev/null 2>&1; then
        health_status="warning"
        issues+=("Git repository integrity issues detected")
    fi
    
    # Check file structure
    local required_dirs=(
        ".claude/commands"
        ".claude/config"
        "scripts/core"
        "scripts/validation"
        "scripts/compliance"
        "docs/principles"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [ ! -d "$PROJECT_ROOT/$dir" ]; then
            health_status="critical"
            issues+=("Missing required directory: $dir")
        fi
    done
    
    # Check script executability
    local core_scripts=(
        "scripts/core/calculate-real-metrics.sh"
        "scripts/validation/validate-system-integrity.sh"
        "scripts/compliance/verify-mathematical-formulas.sh"
    )
    
    for script in "${core_scripts[@]}"; do
        if [ ! -x "$PROJECT_ROOT/$script" ]; then
            health_status="warning"
            issues+=("Script not executable: $script")
        fi
    done
    
    # Generate health report
    local health_report="$PROJECT_ROOT/scripts/results/health-check-$TIMESTAMP.json"
    cat > "$health_report" << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "$health_status",
  "issues": [
$(printf '    "%s",' "${issues[@]}" | sed 's/,$//')
  ],
  "checks_performed": {
    "git_integrity": "$([ $? -eq 0 ] && echo "passed" || echo "failed")",
    "directory_structure": "$([ ${#issues[@]} -eq 0 ] && echo "passed" || echo "warning")",
    "script_permissions": "checked",
    "total_issues": ${#issues[@]}
  }
}
EOF
    
    log "üè• Health check completed: $health_status (${#issues[@]} issues)"
    
    if [ ${#issues[@]} -gt 0 ]; then
        log "‚ö†Ô∏è  Issues detected:"
        for issue in "${issues[@]}"; do
            log "   - $issue"
        done
    fi
    
    return $([ "$health_status" = "critical" ] && echo 1 || echo 0)
}

# Main execution
main() {
    local workflow="$1"
    shift
    
    case "$workflow" in
        "daily-maintenance")
            daily_maintenance
            ;;
        "pattern-crystallization")
            pattern_crystallization_workflow
            ;;
        "release")
            automated_release_workflow "$1"
            ;;
        "ci-simulation")
            ci_simulation
            ;;
        "performance-optimization")
            performance_optimization_workflow
            ;;
        "health-check")
            health_check_workflow
            ;;
        "full-automation")
            log "ü§ñ Running full automation suite..."
            daily_maintenance
            pattern_crystallization_workflow
            performance_optimization_workflow
            health_check_workflow
            log "‚úÖ Full automation suite completed"
            ;;
        *)
            echo "Automated Git Workflows for Context Engineering"
            echo ""
            echo "Usage: $0 <workflow> [arguments]"
            echo ""
            echo "Workflows:"
            echo "  daily-maintenance           Daily system maintenance"
            echo "  pattern-crystallization     Auto-detect and crystallize patterns"
            echo "  release <type>              Automated release (major|minor|patch)"
            echo "  ci-simulation               Simulate CI pipeline locally"
            echo "  performance-optimization    Auto-detect optimization opportunities"
            echo "  health-check                System health validation"
            echo "  full-automation             Run complete automation suite"
            echo ""
            echo "Examples:"
            echo "  $0 daily-maintenance"
            echo "  $0 release minor"
            echo "  $0 full-automation"
            ;;
    esac
}

# Script execution
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
    if [ $# -eq 0 ]; then
        main "help"
    else
        main "$@"
    fi
fi