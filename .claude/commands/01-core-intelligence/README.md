# Comandos At√≥micos - √çndice de Navegaci√≥n

## Estructura Organizacional

Los comandos at√≥micos est√°n organizados en **8 grupos tem√°ticos** que reflejan la arquitectura del sistema Context Engineering:

---

## üìÅ 01. Inteligencia Fundamental
**Filosof√≠a**: Comandos que establecen la base conceptual e intelectual del sistema

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `meta-principle` | #1 | Filosof√≠a fundacional "Stop trying to control the model. Enable it." |
| `progressive-intelligence` | #22 | Desarrollo de inteligencia por etapas (Contextual ‚Üí Strategic ‚Üí Implementation ‚Üí Verification) |
| `orchestrate-intelligence` | #37 | Coordinaci√≥n de inteligencia distribuida con hasta 10 agentes |
| `evolve-intelligence` | #40 | Evoluci√≥n inteligente del sistema basada en patrones de uso |
| `enable-dont-control` | #3 | Principio de habilitaci√≥n vs control para autonom√≠a del modelo |

**Flujo de dependencias**: `meta-principle` ‚Üí `progressive-intelligence` ‚Üí `orchestrate-intelligence` ‚Üí `evolve-intelligence`

---

## üìÅ 02. Verificaci√≥n Matem√°tica
**Filosof√≠a**: Comandos que aseguran rigor matem√°tico y verificaci√≥n continua

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `verify-mathematics-loops` | #33 | Verificaci√≥n recursiva con criterios de convergencia matem√°tica |
| `verify-mathematics` | #41 | Validaci√≥n matem√°tica de resultados y decisiones |
| `mathematical-loops` | #42 | Bucles matem√°ticos de optimizaci√≥n y mejora continua |
| `mathematical-simplicity` | #43 | Aplicaci√≥n de principios de simplicidad matem√°tica |
| `confidence-scoring` | #32 | Puntuaci√≥n de confianza multi-dimensional |
| `complexity-enforcement` | #24 | Aplicaci√≥n de simplicidad usando f√≥rmula C = (S √ó F √ó D √ó R) / (A √ó P) |
| `threshold-enforcement` | #25 | Aplicaci√≥n de umbrales de calidad y performance |
| `verification-loops` | #4 | Bucles de verificaci√≥n iterativa |
| `verification-liberation` | #26 | Liberaci√≥n a trav√©s de verificaci√≥n rigurosa |

**Flujo de dependencias**: `verify-mathematics` ‚Üí `confidence-scoring` ‚Üí `verify-mathematics-loops` ‚Üí `complexity-enforcement`

---

## üìÅ 03. Exploraci√≥n y Descubrimiento
**Filosof√≠a**: Comandos que priorizan el descubrimiento sistem√°tico antes de la implementaci√≥n

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `exploration-first` | #2 | Exploraci√≥n sistem√°tica antes de cualquier implementaci√≥n |
| `recognize-patterns` | #6 | Identificaci√≥n de patrones reutilizables para cristalizaci√≥n |
| `crystallize-patterns` | #5 | Transformaci√≥n de patrones exitosos en comandos reutilizables |
| `objective-decomposition` | #7 | Descomposici√≥n de objetivos complejos en sub-objetivos manejables |

**Flujo de dependencias**: `exploration-first` ‚Üí `recognize-patterns` ‚Üí `crystallize-patterns` ‚Üí `objective-decomposition`

---

## üìÅ 04. Orquestaci√≥n de Flujo
**Filosof√≠a**: Comandos que coordinan la ejecuci√≥n de procesos complejos

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `multi-agent-orchestration` | #36 | Orquestaci√≥n de m√∫ltiples agentes especializados |
| `parallel-over-sequential` | #10 | Priorizaci√≥n de ejecuci√≥n paralela sobre secuencial |
| `git-worktrees-parallel` | #11 | Desarrollo paralelo usando git worktrees |
| `strategic-git` | #9 | Git como red de seguridad y documentaci√≥n de progreso |
| `conversation-lifecycle` | #8 | Gesti√≥n del ciclo de vida de conversaciones |

**Flujo de dependencias**: `parallel-over-sequential` ‚Üí `git-worktrees-parallel` ‚Üí `multi-agent-orchestration` ‚Üí `strategic-git`

---

## üìÅ 05. Optimizaci√≥n de Contexto
**Filosof√≠a**: Comandos que maximizan funcionalidad con m√≠nimo uso de recursos

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `context-economy` | #25 | Econom√≠a de contexto (80% reducci√≥n manteniendo 100% funcionalidad) |
| `optimize-context` | #27 | Optimizaci√≥n inteligente de contexto |
| `context-over-commands` | #28 | Priorizaci√≥n de contexto sobre comandos |
| `single-source-truth` | #26 | Establecimiento de fuente √∫nica de verdad |
| `optimize-complexity` | #29 | Optimizaci√≥n de complejidad del sistema |

**Flujo de dependencias**: `single-source-truth` ‚Üí `context-economy` ‚Üí `optimize-context` ‚Üí `optimize-complexity`

---

## üìÅ 06. Arquitectura del Sistema
**Filosof√≠a**: Comandos que definen la estructura y organizaci√≥n evolutiva del sistema

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `modular-composition` | #12 | Composici√≥n modular de componentes reutilizables |
| `organizational-architecture` | #28 | Arquitectura organizacional auto-evolutiva |
| `optimize-cognitive-organization` | #30 | Organizaci√≥n cognitiva del conocimiento |
| `knowledge-hierarchy` | #29 | Jerarqu√≠a de conocimiento accesible y buscable |
| `evolution-ready-architecture` | #31 | Arquitectura preparada para evoluci√≥n |
| `living-documentation` | #27 | Documentaci√≥n viva que se actualiza autom√°ticamente |

**Flujo de dependencias**: `modular-composition` ‚Üí `organizational-architecture` ‚Üí `knowledge-hierarchy` ‚Üí `living-documentation`

---

## üìÅ 07. Metodolog√≠a de Desarrollo
**Filosof√≠a**: Comandos que implementan mejores pr√°cticas de desarrollo

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `tdd` | #13 | Desarrollo dirigido por pruebas con verificaci√≥n continua |
| `invisible-excellence` | #15 | Excelencia invisible que funciona en el trasfondo |
| `planning-documentation` | #39 | Documentaci√≥n de √°rboles de planificaci√≥n |
| `update-living-docs` | #16 | Actualizaci√≥n autom√°tica de documentaci√≥n viva |

**Flujo de dependencias**: `tdd` ‚Üí `invisible-excellence` ‚Üí `planning-documentation` ‚Üí `update-living-docs`

---

## üìÅ 08. Herramientas y Automatizaci√≥n
**Filosof√≠a**: Comandos que coordinan herramientas y procesos automatizados

| Comando | Principio | Descripci√≥n |
|---------|-----------|-------------|
| `model-selection` | #34 | Selecci√≥n inteligente de modelos basada en contexto |
| `explicit-decision-trees` | #35 | √Årboles de decisi√≥n expl√≠citos para routing |

**Flujo de dependencias**: `explicit-decision-trees` ‚Üí `model-selection`

---

## üîó Relaciones Principales Entre Grupos

### Flujo Central de Orquestaci√≥n
```
01-inteligencia-fundamental ‚Üí 02-verificacion-matematica ‚Üí 03-exploracion-descubrimiento ‚Üí 04-orquestacion-flujo
```

### Flujo de Optimizaci√≥n
```
05-optimizacion-contexto ‚Üí 06-arquitectura-sistema ‚Üí 07-metodologia-desarrollo ‚Üí 08-herramientas-automatizacion
```

### Flujos Transversales
- **Verificaci√≥n**: Grupo 2 alimenta todos los dem√°s grupos
- **Patrones**: Grupo 3 identifica patrones que se cristalizan en todos los grupos
- **Contexto**: Grupo 5 optimiza el uso de recursos en todos los procesos
- **Documentaci√≥n**: Grupo 6 mantiene la documentaci√≥n viva de todo el sistema

---

## üéØ Uso Recomendado

### Para Comenzar
1. Leer `/meta-principle` para entender la filosof√≠a fundacional
2. Aplicar `/exploration-first` para cualquier tarea nueva
3. Usar `/progressive-intelligence` para desarrollo incremental

### Para Implementaci√≥n
1. Aplicar `/objective-decomposition` para tareas complejas
2. Usar `/parallel-over-sequential` para optimizaci√≥n
3. Implementar `/verification-loops` para calidad

### Para Mantenimiento
1. Aplicar `/recognize-patterns` para identificar mejoras
2. Usar `/living-documentation` para mantener actualizada la documentaci√≥n
3. Implementar `/context-economy` para optimizaci√≥n de recursos

---

**Total de comandos**: 37 comandos activos organizados en 8 grupos tem√°ticos
**√öltima actualizaci√≥n**: 2025-07-15
**Versi√≥n**: 1.0 - Reorganizaci√≥n inicial