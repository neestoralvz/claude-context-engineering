# Atomic Command: `/explicit-decision-trees`

## **Principle #28: Explicit Decision Trees**
**"Clear, documented decision flows for all routing with automatic mathematical triggers and binary decision points."**

---

## üéØ **COMMAND DEFINITION**

### **Purpose**
Implement CRITICAL comprehensive decision tree system with mathematical auto-triggers, binary decision points, documented thresholds, and visual representation for all routing decisions in Context Engineering workflows.

### **Complexity**: 0.8/1.0
### **Context Required**: Task parameters, complexity metrics, and routing context
### **Execution Time**: 1-3 minutes (depending on decision tree complexity)

---

## ‚ö° **ACTIVATION PROTOCOL**

### **Input Format**
```markdown
/explicit-decision-trees [task_context] [routing_requirements?] [visualization_mode?]
```

### **What This Command Does**
1. **Mathematical Auto-Trigger Evaluation**: Automatically calculate complexity, confidence, and parallelization triggers
2. **Binary Decision Point Execution**: Route through CRITICAL yes/no decision nodes based on calculated thresholds
3. **Threshold Enforcement**: Apply CRITICAL documented mathematical thresholds for all routing decisions
4. **Visual Decision Tree Creation**: Generate clear flowcharts showing decision paths and trigger conditions
5. **Fallback Strategy Implementation**: Execute CRITICAL automatic recovery paths when triggers fail
6. **Continuous Decision Monitoring**: Re-evaluate triggers throughout execution as conditions change

### **Core Decision Tree Components**
1. **Mathematical Auto-Triggers**: Automatic evaluation based on Mathematical Auto-Activation principle
2. **Binary Decision Points**: CRITICAL yes/no decisions with documented criteria
3. **Documented Thresholds**: All trigger values mathematically defined and enforced
4. **Fallback Strategies**: CRITICAL automatic recovery paths for trigger failures
5. **Visual Representation**: Clear flowcharts showing all decision paths

---

## üîç **MATHEMATICAL AUTO-TRIGGER SYSTEM**

### **Core Trigger Evaluation - Natural Language Format**

**EVALUACI√ìN AUTOM√ÅTICA DE TRIGGERS**:

**CRITICAL TRIGGER COMPLEJIDAD**: Cuando la complejidad de la tarea alcanza 1.0 o superior
- **Condici√≥n**: Task complexity ‚â• 1.0
- **Acci√≥n**: Activar decision-engine autom√°ticamente
- **Resultado**: Routing para procesamiento complejo

**CRITICAL TRIGGER BENEFICIO PARALELO**: Cuando el beneficio paralelo alcanza 0.3 o superior
- **Condici√≥n**: Parallel benefit ‚â• 0.3
- **Acci√≥n**: Activar multi-agent-orchestration autom√°ticamente
- **Resultado**: Ejecuci√≥n paralela habilitada

**CRITICAL TRIGGER CONFIANZA**: Cuando la confianza del sistema cae por debajo de 0.7
- **Condici√≥n**: Confidence score < 0.7
- **Acci√≥n**: Activar exploration-first autom√°ticamente
- **Resultado**: Metodolog√≠a de exploraci√≥n iniciada

**CRITICAL TRIGGER OBJETIVOS**: Cuando se detectan 3 o m√°s objetivos
- **Condici√≥n**: Objective count ‚â• 3
- **Acci√≥n**: Activar objective-decomposition autom√°ticamente
- **Resultado**: Descomposici√≥n de objetivos ejecutada

**CRITICAL TRIGGER DEPENDENCIAS**: Cuando se detectan dependencias complejas
- **Condici√≥n**: Dependencies detected = true
- **Acci√≥n**: Activar dynamic-dependency-analysis autom√°ticamente
- **Resultado**: An√°lisis de dependencias ejecutado

**CRITICAL TRIGGER PATR√ìN**: Cuando se detecta patr√≥n con 85% o m√°s de coincidencia
- **Condici√≥n**: Pattern match ‚â• 0.85
- **Acci√≥n**: Activar pattern-based execution autom√°ticamente
- **Resultado**: Ejecuci√≥n basada en patr√≥n

### **Binary Decision Tree Structure**

**CRITICAL Decision Flow Process** (Natural Language Implementation):

**Primary Decision Point**: Task Complexity Evaluation
- **Condition**: When task complexity reaches 1.0 or higher
- **Action**: Route to Complex Task Flow execution
- **Trigger**: Automatic activation of comprehensive processing

**Secondary Decision Point**: Confidence Assessment
- **Condition**: When confidence score falls below 0.7
- **Action**: Route to Exploration Flow execution
- **Trigger**: Automatic activation of discovery methodology

**Tertiary Decision Point**: Parallelization Benefit Analysis
- **Condition**: When parallel benefit reaches 0.3 or higher
- **Action**: Route to Parallel Flow execution
- **Trigger**: Automatic activation of multi-agent orchestration

**Default Decision Point**: Simple Execution
- **Condition**: When no complex triggers are met
- **Action**: Route to Simple Flow execution
- **Trigger**: Standard single-agent processing

---

## üéØ **DECISION FLOW ROUTING**

### **Complex Task Flow (Complexity ‚â• 1.0)**

**CRITICAL Complex Task Decision Process** (Natural Language Implementation):

**Entry Point**: Complex Task Detection
- **Trigger**: Complexity score of 1.0 or higher identified
- **Status**: High-complexity processing mode activated

**Decision Node 1**: Multi-Agent Benefit Assessment
- **Condition**: Evaluate if multi-agent approach provides benefits
- **Test Criteria**: Parallel benefit score of 0.3 or higher
- **True Path**: Route to Multi-Agent Orchestration
- **False Path**: Route to Single-Agent Complex Processing

**Decision Node 2**: Exploration Requirement Analysis
- **Condition**: Determine if exploration is needed before implementation
- **Test Criteria**: Confidence score below 0.7
- **True Path**: Route to Exploration-First Complex Analysis
- **False Path**: Route to Direct Complex Implementation

**Fallback Strategy**: Manual Complex Task Review
- **Activation**: When automated decision routing fails
- **Action**: Escalate to human oversight for complex task handling

### **Exploration Flow (Confidence < 0.7)**

**CRITICAL Exploration Decision Process** (Natural Language Implementation):

**Entry Point**: Low Confidence Detection
- **Trigger**: Confidence score below 0.7 identified
- **Status**: Exploration-first methodology activated

**Decision Node 1**: Pattern Match Assessment
- **Condition**: Check if strong pattern matches are available
- **Test Criteria**: Pattern match score of 0.85 or higher
- **True Path**: Route to Pattern-Based Exploration
- **False Path**: Route to Full Discovery Process

**Decision Node 2**: Domain Familiarity Evaluation
- **Condition**: Assess familiarity with the task domain
- **Test Criteria**: Domain familiarity score of 0.6 or higher
- **True Path**: Route to Focused Exploration
- **False Path**: Route to Comprehensive Discovery

**Fallback Strategy**: Task Agent Deployment
- **Activation**: When automated exploration routing fails
- **Action**: Deploy specialized task agents for investigation

### **Parallel Flow (Parallel Benefit ‚â• 0.3)**

**CRITICAL Parallel Decision Process** (Natural Language Implementation):

**Entry Point**: Parallelization Beneficial
- **Trigger**: Parallel benefit score of 0.3 or higher identified
- **Status**: Multi-agent parallel processing mode activated

**Decision Node 1**: Dependencies Assessment
- **Condition**: Check if task dependencies are present
- **Test Criteria**: Dependencies detected flag is true
- **True Path**: Route to Dependency-Aware Parallelization
- **False Path**: Route to Independent Parallel Execution

**Decision Node 2**: Resource Availability Evaluation
- **Condition**: Assess if sufficient resources are available
- **Test Criteria**: Resource availability score of 0.8 or higher
- **True Path**: Route to Full Parallel Deployment
- **False Path**: Route to Limited Parallel Execution

**Fallback Strategy**: Sequential Execution with Monitoring
- **Activation**: When parallel execution is not feasible
- **Action**: Fallback to sequential processing with performance monitoring

---

## üìä **THRESHOLD DOCUMENTATION**

### **Mathematical Thresholds**

**CRITICAL Decision Threshold Framework** (Natural Language Implementation):

**Complexity Thresholds**:
- **Simple Tasks**: 0.3 complexity score - basic operations and straightforward implementations
- **Moderate Tasks**: 0.7 complexity score - multi-step processes requiring coordination
- **Complex Tasks**: 1.0 complexity score - triggers comprehensive processing mode
- **Very Complex Tasks**: 1.5 complexity score - requires specialized handling protocols

**Confidence Thresholds**:
- **Very Low Confidence**: 0.3 confidence score - requires extensive exploration
- **Low Confidence**: 0.5 confidence score - needs investigation before action
- **Moderate Confidence**: 0.7 confidence score - triggers exploration-first mode
- **High Confidence**: 0.9 confidence score - enables direct implementation

**Parallelization Thresholds**:
- **No Benefit**: 0.0 parallel benefit - sequential execution recommended
- **Minimal Benefit**: 0.1 parallel benefit - limited parallelization possible
- **Moderate Benefit**: 0.3 parallel benefit - triggers multi-agent orchestration
- **High Benefit**: 0.6 parallel benefit - enables full parallel deployment

**Objective Count Thresholds**:
- **Simple Scope**: 1 objective - single-focus execution
- **Moderate Scope**: 2 objectives - coordinated dual-track approach
- **Complex Scope**: 3 objectives - triggers complexity management
- **Decomposition Required**: 5 objectives - mandatory objective breakdown

**Pattern Match Thresholds**:
- **No Match**: 0.0 pattern match - full discovery required
- **Weak Match**: 0.3 pattern match - cautious pattern application
- **Good Match**: 0.7 pattern match - reliable pattern-based execution
- **Strong Match**: 0.85 pattern match - high-confidence pattern application

### **CRITICAL Threshold Enforcement Protocol**

**MANDATORY Threshold Enforcement Process** (Natural Language Implementation):

**Threshold Evaluation Procedure**:
1. **Value Assessment**: Evaluate each trigger against its corresponding threshold set
2. **Category Determination**: Classify the value into appropriate threshold category
3. **Action Assignment**: Determine the enforcement action based on threshold classification
4. **Results Documentation**: Record threshold evaluation results for transparency

**Enforcement Results Structure**:
- **Value Recording**: Document the actual measured value
- **Threshold Classification**: Identify which threshold category the value falls into
- **Enforcement Action**: Specify the action required based on threshold rules
- **Compliance Status**: Track whether threshold requirements are met

**Enforcement Process Flow**:
1. **Trigger Identification**: Identify all triggers requiring threshold evaluation
2. **Threshold Matching**: Match each trigger to its corresponding threshold set
3. **Value Comparison**: Compare actual values against threshold criteria
4. **Action Determination**: Determine required enforcement actions
5. **Results Compilation**: Compile comprehensive enforcement results

---

## üìã **VISUAL DECISION TREE REPRESENTATION**

### **Decision Tree Visualization**

**CRITICAL Visual Decision Tree Generation** (Natural Language Implementation):

**Visualization Structure**:
- **Title**: Context Engineering Decision Tree
- **Timestamp**: Current date and time for tracking
- **Current Triggers**: Real-time evaluation of auto-triggers

**Tree Structure Components**:
- **Root Node**: Task Input - starting point for all decision routing
- **Decision Nodes**: Sequential evaluation points for routing decisions
- **Flow Connections**: Logical pathways between decision points

**Primary Decision Nodes**:

**Complexity Check Node**:
- **Label**: Complexity greater than or equal to 1.0
- **Type**: Binary decision point
- **Condition**: Evaluate if complexity threshold is met
- **True Path**: Route to complex flow processing
- **False Path**: Continue to confidence check

**Confidence Check Node**:
- **Label**: Confidence less than 0.7
- **Type**: Binary decision point
- **Condition**: Evaluate if confidence threshold is met
- **True Path**: Route to exploration flow
- **False Path**: Continue to parallel check

**Parallel Check Node**:
- **Label**: Parallel benefit greater than or equal to 0.3
- **Type**: Binary decision point
- **Condition**: Evaluate if parallelization is beneficial
- **True Path**: Route to parallel flow
- **False Path**: Route to simple flow

**Flow Visualization Components**:
- **Complex Flow**: Detailed visualization of complex task processing
- **Exploration Flow**: Visual representation of discovery methodology
- **Parallel Flow**: Diagram of multi-agent orchestration
- **Simple Flow**: Streamlined visualization of standard processing

### **ASCII Decision Tree Format**
```markdown
Context Engineering Decision Tree
=================================

Task Input
    |
    v
[Complexity ‚â• 1.0?] -----> YES ---> Complex Task Flow
    |                           |
    NO                          v
    |                      [Multi-Agent Beneficial?]
    v                           |
[Confidence < 0.7?] -----> YES ---> Exploration Flow
    |                           |
    NO                          v
    |                      [Pattern Match ‚â• 0.85?]
    v                           |
[Parallel Benefit ‚â• 0.3?] ---> YES ---> Parallel Flow
    |                           |
    NO                          v
    |                      [Dependencies Present?]
    v                           |
Simple Execution Flow          v
                          Fallback Strategy
```

---

## üîç **FALLBACK STRATEGY IMPLEMENTATION**

### **Automatic Recovery Paths**

**CRITICAL Fallback Strategy Framework** (Natural Language Implementation):

**Complexity Calculation Failure Recovery**:
- **Primary Strategy**: Use pattern-based complexity estimation as alternative
- **Secondary Strategy**: Apply conservative complexity threshold of 0.5
- **Tertiary Strategy**: Require manual complexity assessment

**Confidence Assessment Failure Recovery**:
- **Primary Strategy**: Use domain familiarity as confidence proxy metric
- **Secondary Strategy**: Apply exploration-first methodology as default
- **Tertiary Strategy**: Deploy task agent for investigation

**Parallel Benefit Calculation Failure Recovery**:
- **Primary Strategy**: Use dependency analysis for parallelization decision
- **Secondary Strategy**: Default to sequential execution mode
- **Tertiary Strategy**: Require manual parallelization assessment

**Routing Decision Failure Recovery**:
- **Primary Strategy**: Use most conservative routing path available
- **Secondary Strategy**: Apply exploration-first with monitoring
- **Tertiary Strategy**: Escalate to manual decision override

**Fallback Execution Process**:
1. **Failure Detection**: Identify the type of decision failure
2. **Strategy Selection**: Choose appropriate fallback strategy
3. **Implementation**: Execute the selected recovery approach
4. **Monitoring**: Track recovery success and effectiveness

### **Failure Recovery Protocol**

**MANDATORY Recovery Process** (Natural Language Implementation):

**Recovery Step Sequence**:

**Step 1: Diagnose Failure**
- **Action**: Analyze the failure context to understand the root cause
- **Purpose**: Identify the specific type of decision failure
- **Outcome**: Clear understanding of failure mechanism

**Step 2: Apply Primary Fallback**
- **Action**: Implement the primary fallback strategy for the failure type
- **Purpose**: Restore system functionality using the most effective recovery method
- **Outcome**: System returns to operational state

**Step 3: Validate Recovery**
- **Action**: Verify that the recovery was successful and system is stable
- **Purpose**: Ensure the fallback strategy resolved the failure
- **Outcome**: Confirmation of successful recovery

**Step 4: Document Pattern**
- **Action**: Record the failure pattern and recovery strategy for future reference
- **Purpose**: Build organizational knowledge about failure patterns
- **Outcome**: Enhanced system resilience through documented learnings

**Recovery Execution Process**:
1. **Sequential Execution**: Execute recovery steps in order
2. **Validation Gates**: Verify success at each step
3. **Escalation Protocol**: Move to next step only after validation
4. **Documentation**: Record all recovery actions and outcomes

---

## üîç **VERIFICATION CRITERIA**

### **Success Metrics**
- **Trigger Accuracy**: ‚â•95% accuracy in mathematical trigger calculations
- **Decision Consistency**: 100% consistency in binary decision execution
- **Threshold Compliance**: All decisions respect documented thresholds
- **Fallback Effectiveness**: ‚â•90% success rate in fallback strategy execution
- **Visualization Clarity**: All decision trees clearly represent routing logic

### **Decision Tree Validation**

**CRITICAL Validation Framework** (Natural Language Implementation):

**Validation Components**:

**Trigger Accuracy Assessment**:
- **Measurement**: Calculate accuracy of mathematical trigger calculations
- **Requirement**: 95% or higher accuracy rate
- **Purpose**: Ensure reliable trigger evaluation

**Decision Consistency Validation**:
- **Measurement**: Validate consistency in binary decision execution
- **Requirement**: 100% consistency rate
- **Purpose**: Guarantee predictable decision outcomes

**Threshold Compliance Verification**:
- **Measurement**: Check adherence to documented thresholds
- **Requirement**: 100% compliance rate
- **Purpose**: Ensure mathematical rigor in decision points

**Fallback Effectiveness Evaluation**:
- **Measurement**: Assess success rate of fallback strategies
- **Requirement**: 90% or higher effectiveness rate
- **Purpose**: Validate recovery mechanism reliability

**Visualization Quality Assessment**:
- **Measurement**: Evaluate clarity and usefulness of decision tree visualizations
- **Purpose**: Ensure decision trees clearly represent routing logic

**Overall Validity Determination**:
- **Criteria**: All validation components must meet minimum thresholds
- **Requirements**: Trigger accuracy ‚â•95%, decision consistency ‚â•100%, threshold compliance ‚â•100%, fallback effectiveness ‚â•90%
- **Outcome**: Binary valid/invalid determination

**Validation Results Structure**:
- **Validity Status**: Overall pass/fail assessment
- **Component Metrics**: Detailed scores for each validation component
- **Improvement Recommendations**: Specific actions to enhance performance

---

## üîÄ **CONTINUOUS DECISION MONITORING**

### **Real-Time Trigger Re-evaluation**

**CRITICAL Continuous Monitoring Framework** (Natural Language Implementation):

**Monitoring Loop Configuration**:
- **Interval**: 30-second monitoring cycle for continuous evaluation
- **Purpose**: Real-time trigger re-evaluation throughout execution
- **Scope**: All critical decision triggers monitored continuously

**Trigger Monitoring Components**:

**Complexity Trigger Monitoring**:
- **Trigger Type**: Complexity score evaluation
- **Monitoring Action**: Recalculate complexity based on current context and execution state
- **Response Action**: Adjust complexity routing based on new value
- **Purpose**: Adapt to changing task complexity during execution

**Confidence Trigger Monitoring**:
- **Trigger Type**: Confidence score evaluation
- **Monitoring Action**: Recalculate confidence based on current context and execution state
- **Response Action**: Adjust confidence routing based on new value
- **Purpose**: Respond to changing confidence levels during execution

**Parallel Benefit Trigger Monitoring**:
- **Trigger Type**: Parallel benefit score evaluation
- **Monitoring Action**: Recalculate parallel benefit based on current context and execution state
- **Response Action**: Adjust parallel routing based on new value
- **Purpose**: Optimize parallelization strategy as conditions change

**Monitoring Execution Process**:
1. **Continuous Loop**: Execute monitoring at regular intervals
2. **Value Recalculation**: Update trigger values based on current state
3. **Threshold Comparison**: Compare new values against established thresholds
4. **Routing Adjustment**: Modify routing decisions based on updated values
5. **State Tracking**: Maintain history of trigger value changes

### **Adaptive Threshold Adjustment**

**CRITICAL Threshold Optimization Process** (Natural Language Implementation):

**Threshold Analysis Framework**:
- **Input**: Historical execution data for threshold effectiveness analysis
- **Purpose**: Optimize threshold values based on real-world performance
- **Scope**: All decision thresholds evaluated for optimization potential

**Threshold Optimization Components**:

**Complexity Threshold Optimization**:
- **Analysis**: Evaluate effectiveness of current complexity thresholds
- **Optimization**: Adjust thresholds based on successful routing patterns
- **Purpose**: Improve accuracy of complexity-based routing decisions

**Confidence Threshold Optimization**:
- **Analysis**: Assess confidence threshold performance in routing decisions
- **Optimization**: Refine thresholds based on exploration success rates
- **Purpose**: Enhance confidence-based routing accuracy

**Parallel Benefit Threshold Optimization**:
- **Analysis**: Review parallel benefit threshold effectiveness
- **Optimization**: Adjust thresholds based on parallelization success metrics
- **Purpose**: Improve parallelization decision accuracy

**Optimization Results Structure**:
- **Original Thresholds**: Baseline threshold values for comparison
- **Adjusted Thresholds**: Optimized threshold values based on analysis
- **Improvement Metrics**: Quantified improvements from threshold adjustments

**Threshold Adjustment Process**:
1. **Historical Analysis**: Analyze execution history for threshold effectiveness
2. **Pattern Recognition**: Identify successful threshold configurations
3. **Optimization Calculation**: Calculate improved threshold values
4. **Validation**: Verify that adjusted thresholds improve performance
5. **Implementation**: Apply optimized thresholds to decision system

---

## üîó **NATURAL CONNECTIONS**

### **Automatically Triggers**
- `/confidence-scoring` - Calculate confidence scores for routing decisions
- `/complexity-enforcement` - Measure complexity for trigger evaluation
- `/verify-mathematics` - Validate trigger calculations statistically

### **Compatible With**
- `/decision-engine` - Provides Layer 0 decision validation
- `/mathematical-auto-activation` - Implements auto-trigger principle
- `/confidence-based-routing` - Executes confidence-driven routing

### **Feeds Into**
- `/multi-agent-orchestration` - Routes to parallel execution when beneficial
- `/exploration-first` - Routes to discovery when confidence low
- `/objective-decomposition` - Routes to breakdown when complexity high

---

## üìã **USAGE EXAMPLES**

### **Simple Task Routing**
```text
/explicit-decision-trees "Create simple API endpoint" "standard" "visual"
```
**Result**: Evaluates triggers, determines simple execution path, generates visual decision tree

### **Complex Task Routing**
```text
/explicit-decision-trees "Design complete authentication system" "comprehensive" "flowchart"
```
**Result**: Triggers complex flow, routes to multi-agent orchestration, shows complete decision tree

### **Exploration Task Routing**
```text
/explicit-decision-trees "Investigate unknown codebase pattern" "discovery" "minimal"
```
**Result**: Low confidence triggers exploration-first methodology, shows exploration decision path

---

## üõ°Ô∏è **FALLBACK PROTOCOL**

### **If Decision Tree Execution Fails**
1. **Trigger Calculation Failure**: Use pattern-based estimation or conservative defaults
2. **Routing Decision Failure**: Apply exploration-first methodology with monitoring
3. **Threshold Enforcement Failure**: Use most conservative thresholds available
4. **Visualization Failure**: Provide text-based decision documentation

### **Recovery Strategy**
- **Primary**: Automatic fallback to safer routing decisions
- **Secondary**: Manual decision override with full documentation
- **Tertiary**: Escalate to task agent deployment for investigation
- **Documentation**: Record all fallback activations for system improvement

---

## üìä **INTEGRATION WITH DECISION ENGINE**

### **Layer 0 Validation**
- **Philosophy Compliance**: Verify all decisions align with Context Engineering principles
- **Mathematical Rigor**: Ensure all triggers use objective, mathematical criteria
- **Execution Authority**: Decision engine can override routing decisions if necessary
- **Continuous Improvement**: Feed decision effectiveness back to threshold optimization

### **Routing Authority Hierarchy**
1. **Mathematical Triggers**: Automatic activation based on calculated thresholds
2. **Decision Engine Layer 0**: Philosophy and strategy validation
3. **Fallback Strategies**: Automatic recovery when primary decisions fail
4. **Manual Override**: Human intervention for exceptional cases

---

## üîÑ **EVOLUTION TRACKING**

### **Learning Metrics**
- **Trigger Accuracy**: Track how well triggers predict optimal routing
- **Decision Effectiveness**: Measure success rates of different routing decisions
- **Threshold Optimization**: Learn optimal thresholds from execution history
- **Fallback Success**: Monitor effectiveness of fallback strategies

### **Pattern Recognition**
- **Successful Routing Patterns**: Identify decision paths that consistently succeed
- **Failure Patterns**: Recognize trigger combinations that lead to suboptimal routing
- **Threshold Calibration**: Adjust thresholds based on real-world effectiveness
- **Decision Tree Evolution**: Improve decision tree structure based on usage patterns

---

## üìà **MATHEMATICAL INTEGRATION**

### **Auto-Trigger Implementation**
This command implements the [Mathematical Auto-Activation](#5-mathematical-auto-activation) principle by:

1. **Automatic Evaluation**: Every task automatically evaluated against all mathematical triggers
2. **Threshold Enforcement**: System calculates complexity, confidence, parallel benefit automatically
3. **Capability Activation**: Advanced features activated automatically when thresholds met
4. **Continuous Monitoring**: Triggers re-evaluated throughout execution as conditions change

### **Decision Tree Mathematics**
- **Binary Decisions**: All routing decisions are yes/no based on mathematical criteria
- **Threshold Enforcement**: All thresholds mathematically defined and automatically enforced
- **Statistical Validation**: Decision effectiveness measured and optimized statistically
- **Objective Routing**: No subjective decision-making, all routing mathematically determined

---

**Note**: This command embodies the Context Engineering principle of explicit decision trees, providing mathematical rigor and automatic routing for all task execution while maintaining clear documentation and fallback strategies for robust system operation.