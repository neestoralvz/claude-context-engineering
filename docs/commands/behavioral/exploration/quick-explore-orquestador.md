# Orchestrator Command: `/quick-explore`

## **Optimizaci√≥n: Exploraci√≥n R√°pida Inteligente**
**"Exploraci√≥n eficiente sin overhead para casos de uso comunes."**

---

## üéØ **COMMAND DEFINITION**

### **Purpose**
Orquestrador optimizado para exploraci√≥n r√°pida y eficiente sin el overhead del meta-comando completo. Dise√±ado para casos de uso frecuentes donde necesitas entender r√°pidamente c√≥digo, problemas o sistemas.

### **Complexity**: 1.2/1.0  
### **Context Required**: Objetivo de exploraci√≥n espec√≠fico
### **Execution Time**: 3-5 minutos (60% m√°s r√°pido que meta-comando)

---

## ‚ö° **ACTIVATION PROTOCOL**

### **Usage Format**
```
/quick-explore [objetivo_espec√≠fico]
/qe [objetivo_espec√≠fico]          # shortcut
```

### **Optimizaci√≥n Inteligente**
- **üöÄ Bypass an√°lisis de decisi√≥n**: Va directo a exploraci√≥n
- **‚ö° Paralelizaci√≥n autom√°tica**: Benefit ‚â• 0.4 detectado autom√°ticamente  
- **üéØ Enfoque espec√≠fico**: Solo comandos necesarios para exploraci√≥n
- **üìä Context economy**: 70% reducci√≥n de contexto vs meta-comando

---

## üîó **ORCHESTRATED COMMAND CHAIN**

### **Secuencia Optimizada (3 comandos core)**
**Chain Execution Protocol**

**Primary Sequence**:
1. **knowledge-hierarchy**: B√∫squeda jer√°rquica local ‚Üí external
2. **explore**: Exploraci√≥n obligatoria con patrones
3. **patterns**: Reconocimiento y cristalizaci√≥n

**Parallel Opportunities**:
- knowledge-hierarchy + explore (independientes)
- patterns (depende de resultados de ambos)

**Execution Strategy**:
- If parallel benefit ‚â• 0.4: Ejecutar 1+2 en paralelo, luego 3
- If parallel benefit < 0.4: Ejecuci√≥n secuencial optimizada

### **Context Distribution (Economy Active)**
**Context Distribution (Economy Active)**

**Context per Command**:
- **knowledge-hierarchy**: 
  - Context: objetivo + dominio_espec√≠fico
  - Size: ~20% del contexto total
- **explore**:
  - Context: objetivo + hallazgos_knowledge
  - Size: ~25% del contexto total
- **patterns**:
  - Context: objetivo + exploration_results
  - Size: ~30% del contexto total

**Total Context Economy**: 75% vs meta-comando completo

---

## üìä **MATHEMATICAL VALIDATION**

### **Efficiency Metrics**
```javascript
function calculateQuickExploreEfficiency() {
  const time_saving = 0.6 // 60% m√°s r√°pido que meta-comando
  const context_reduction = 0.75 // 75% menos contexto
  const parallel_benefit = 0.4 // benefit autom√°tico detectado
  const accuracy_maintained = 0.92 // mantenemos 92% de precisi√≥n
  
  return {
    overall_efficiency: (time_saving + context_reduction + parallel_benefit) / 3,
    precision_quality: accuracy_maintained,
    recommended_for: "objetivos_espec√≠ficos_exploraci√≥n"
  }
}
```

### **Success Thresholds**
- **Time Efficiency**: ‚â•50% reducci√≥n vs meta-comando
- **Context Economy**: ‚â•70% reducci√≥n de contexto  
- **Parallel Benefit**: ‚â•40% cuando aplicable
- **Exploration Quality**: ‚â•90% de resultados del meta-comando

---

## üîç **INTELLIGENT ROUTING CRITERIA**

### **Ideal Use Cases (Auto-detect)**
**Perfect Fit Scenarios**:
- Entender este c√≥digo/archivo/funci√≥n
- Investigar problema espec√≠fico
- Buscar patrones en codebase
- Analizar estructura de proyecto
- Explorar dependencias
- Mapear flujo de datos

**Avoid For**:
- Objetivos m√∫ltiples complejos (usar /context-eng)
- Implementaci√≥n code (usar /rapid-prototype)
- Verificaci√≥n sistema (usar /system-health)
- Planning estrat√©gico (usar /planning-workflow)

### **Confidence-Based Routing**
```javascript
function shouldUseQuickExplore(objective, context) {
  const specificity_score = assessObjectiveSpecificity(objective) // 0.0-1.0
  const exploration_focus = detectExplorationKeywords(objective) // boolean
  const complexity_estimate = estimateComplexity(objective) // 0.0-3.0
  
  if (specificity_score >= 0.7 && 
      exploration_focus && 
      complexity_estimate <= 1.5) {
    return { recommended: true, confidence: 0.9 }
  }
  
  return { recommended: false, alternative: "/context-eng" }
}
```

---

## ‚ö° **EXECUTION WORKFLOW**

### **Phase 1: Parallel Knowledge Discovery (2-3 min)**
**Parallel Execution Strategy**:

**Agent 1 (Knowledge Hierarchy)**:
- Task: B√∫squeda sistem√°tica local ‚Üí external
- Context: objetivo + dominio
- Output: knowledge_map

**Agent 2 (Explore)**:
- Task: Exploraci√≥n obligatoria con patrones
- Context: objetivo + exploration_strategy
- Output: exploration_findings

**Coordination Protocol**:
- Simultaneous launch: true
- Progress monitoring: true
- Early termination: si uno encuentra soluci√≥n completa

### **Phase 2: Pattern Synthesis (1-2 min)**
**Pattern Synthesis Process**:
- **Input**: knowledge_map + exploration_findings
- **Process**: consolidar + identificar_patrones + cristalizar
- **Output**: structured_insights + reusable_patterns
- **Documentation**: auto-update living docs si patterns ‚â• threshold

### **Result Format**
**Quick Explore Output Format**:
- **Executive Summary**: 2-3 l√≠neas clave
- **Knowledge Discovered**: mapa de conocimiento estructurado
- **Patterns Identified**: patrones reutilizables encontrados
- **Next Recommended Actions**: sugerencias espec√≠ficas
- **Crystallization Opportunities**: si aplica
- **Execution Time**: tiempo real vs estimado

---

## üîÄ **INTELLIGENT CHAINING**

### **Auto-Chain Opportunities**
**Natural Follow-up Suggestions**:

**If Patterns Found**:
- Suggest: /crystallize-patterns
- Confidence: 0.85

**If Implementation Needed**:
- Suggest: /rapid-prototype
- Confidence: 0.9

**If Verification Required**:
- Suggest: /verify-flow
- Confidence: 0.8

**If More Depth Needed**:
- Suggest: /context-eng [specific_area]
- Confidence: 0.7

### **Escalation Protocol**
**Escalation Triggers**:
  - **If Complexity Exceeds 1.5**: auto-suggest /context-eng
  - **If Multiple Objectives Detected**: auto-suggest /smart-workflow
  - **If Implementation Scope Large**: auto-suggest /planning-workflow
  - **If Exploration Insufficient**: auto-trigger second round with /explore

---

## üìã **USAGE EXAMPLES**

### **Example 1: Codebase Understanding**
```bash
/qe "entender c√≥mo funciona el sistema de autenticaci√≥n en este proyecto"
```
**Result**: 
- Knowledge map de auth flow
- Patrones de seguridad identificados
- Dependencies y integration points
- Sugerencias de mejora

### **Example 2: Problem Investigation**
```bash  
/qe "investigar por qu√© la build est√° fallando en CI/CD"
```
**Result**:
- Mapeo de pipeline y dependencies
- Puntos de fallo identificados
- Patrones de error encontrados
- Next steps espec√≠ficos

### **Example 3: Architecture Analysis**
```bash
/qe "analizar la arquitectura de datos de esta aplicaci√≥n"
```
**Result**:
- Data flow mapping
- Storage patterns
- Integration dependencies  
- Optimization opportunities

---

## üõ°Ô∏è **FALLBACK PROTOCOLS**

### **If Quick Exploration Insufficient**
1. **Auto-escalate**: Sugerir `/context-eng` con contexto espec√≠fico
2. **Chain suggestion**: Recomendar `/rapid-prototype` para implementaci√≥n
3. **Deep dive**: Activar `/exploration-first` para an√°lisis m√°s profundo

### **Quality Assurance**
**Quality Assurance Checks**:
- **Minimum Insights**: 3
- **Pattern Discovery Rate**: ‚â•60%
- **Actionable Next Steps**: ‚â•2
- **Execution Time Limit**: 6 minutes max

**Fallback If Failed**:
- Retry with enhanced context: true
- Escalate to meta command: after 2 failed attempts
- Document failure pattern: true

---

## üéØ **INTEGRATION WITH DECISION ENGINE**

### **Decision Engine Bypass**
**Decision Engine Bypass Protocol**:

**When**: clear_exploration_objective_detected

**Conditions**:
- Objective specificity ‚â• 0.7
- Exploration keywords present
- Complexity estimate ‚â§ 1.5
- No implementation scope detected

**Execution**:
- Direct execution: true
- Skip analysis phases: complexity_analysis, model_selection, planning
- Maintain monitoring: true

### **Smart Re-routing**
```javascript
function smartReroutingLogic(exploration_results) {
  if (exploration_results.complexity_discovered > 1.5) {
    return suggestEscalation("/context-eng", exploration_results.context)
  }
  
  if (exploration_results.implementation_scope_detected) {
    return suggestChaining("/rapid-prototype", exploration_results.insights)
  }
  
  if (exploration_results.patterns_found >= 3) {
    return suggestFollowUp("/crystallize-patterns", exploration_results.patterns)
  }
  
  return { completed: true, satisfied: true }
}
```

---

## üìä **SUCCESS METRICS & LEARNING**

### **Performance Tracking**
**Metrics to Track**:
- **Execution Time**: target 3-5 min
- **Context Efficiency**: target 75% reduction
- **Parallel Benefit Achieved**: target ‚â•40%
- **Exploration Quality**: target ‚â•90% of meta-comando results
- **User Satisfaction**: target ‚â•85%
- **Escalation Rate**: target ‚â§15%

### **Learning Loop**
**Continuous Improvement Learning Loop**:

**Pattern Detection**:
- Successful exploration patterns ‚Üí enhance knowledge hierarchy
- Common follow-up chains ‚Üí improve auto suggestions
- Escalation triggers ‚Üí refine complexity detection

**Optimization Opportunities**:
- Reduce execution time further
- Improve parallel coordination
- Enhance pattern synthesis quality

---

## üîó **NATURAL CONNECTIONS**

### **Feeds Into**
- `/rapid-prototype` - When implementation is needed
- `/crystallize-patterns` - When patterns are discovered
- `/context-eng` - When complexity exceeds scope
- `/verify-flow` - When validation is required

### **Feeds From**  
- `/smart-workflow` - As recommended exploration approach
- Direct user invocation for specific exploration needs
- Auto-suggestion from other commands when exploration is needed

---

**Note**: Este orquestrador optimiza el caso de uso m√°s com√∫n (exploraci√≥n espec√≠fica) eliminando overhead innecesario mientras mantiene la calidad de resultados. Implementa Context Economy, paralelizaci√≥n inteligente, y escalaci√≥n autom√°tica cuando la complejidad excede el scope.
